// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package dependencyInjection

import (
	"Demonstration-Service/internal/Application/Services"
	"Demonstration-Service/internal/Infrastructure/kafka"
	"Demonstration-Service/internal/Infrastructure/post"
	"Demonstration-Service/internal/Infrastructure/storages/dataAccess"
	"Demonstration-Service/internal/Infrastructure/storages/redisCache"
	configs2 "Demonstration-Service/internal/run/configs"
	grpcConfig2 "Demonstration-Service/internal/run/configs/grpcConfig"
	httpConfig2 "Demonstration-Service/internal/run/configs/httpConfig"
	"context"
	"database/sql"
	"github.com/redis/go-redis/v9"
	"go.uber.org/zap"
	"time"
)

// Injectors from wire.go:

func InitializeApplication(ctx context.Context) (*Application, error) {
	string2 := provideLogFilePath()
	logger, err := configs2.InitLogger(string2)
	if err != nil {
		return nil, err
	}
	db, err := configs2.GetUpSQL()
	if err != nil {
		return nil, err
	}
	redisConfig := provideRedisConfig()
	client, err := configs2.NewClient(ctx, redisConfig)
	if err != nil {
		return nil, err
	}
	duration := provideCacheExpiration()
	redisRepository := redisCache.NewRedisRepository(client, duration)
	ordersRepo := dataAccess.NewOrdersRepo(db)
	readDataService := Services.NewReadDataService(redisRepository, ordersRepo)
	processDataService := Services.NewProcessDataService(redisRepository, ordersRepo)
	server := grpcConfig2.ServerGetUp(readDataService, logger)
	httpConfigServer := httpConfig2.ServerGetUp(readDataService, logger)
	kafkaConfig := configs2.NewKafkaConfig()
	processService := post.NewProcessService(processDataService)
	consumer := kafka.NewKafkaConsumer(kafkaConfig, processService)
	application := NewApplication(logger, db, client, readDataService, processDataService, server, httpConfigServer, consumer)
	return application, nil
}

// wire.go:

func provideLogFilePath() string {
	return "logs/app.log"
}

func provideRedisConfig() configs2.RedisConfig {
	return *configs2.NewRedisConfig()
}

func provideContext() context.Context {
	return context.Background()
}

func provideCacheExpiration() time.Duration {
	return 30 * time.Minute
}

type Application struct {
	Logger        *zap.Logger
	db            *sql.DB
	redisClient   *redis.Client
	readService   *Services.ReadDataService
	addService    *Services.ProcessDataService
	GrpcServer    *grpcConfig2.Server
	HttpServer    *httpConfig2.Server
	KafkaConsumer *kafka.Consumer
}

func NewApplication(
	Logger *zap.Logger,
	db *sql.DB,
	redisClient *redis.Client,
	readService *Services.ReadDataService,
	addService *Services.ProcessDataService,
	GrpcServer *grpcConfig2.Server,
	HttpServer *httpConfig2.Server,
	KafkaConsumer *kafka.Consumer,
) *Application {
	return &Application{
		Logger:        Logger,
		db:            db,
		redisClient:   redisClient,
		readService:   readService,
		addService:    addService,
		GrpcServer:    GrpcServer,
		HttpServer:    HttpServer,
		KafkaConsumer: KafkaConsumer,
	}
}
